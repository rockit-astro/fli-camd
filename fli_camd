#!/usr/bin/env python3.6
#
# This file is part of fli-camd.
#
# fli-camd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# fli-camd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fli-camd.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling an FLI ML50100 camera via Pyro"""

# pylint: disable=too-many-return-statements
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-lines
# pylint: disable=too-many-branches
# pylint: disable=too-many-statements

import argparse
from ctypes import (c_bool, c_double, c_long, c_size_t, c_uint16, c_char_p,
                    byref, create_string_buffer, sizeof, POINTER, CDLL)
import datetime
import json
from multiprocessing import Process, Queue, Value
import os.path
import pathlib
import shutil
import threading
import time
from astropy.io import fits
import numpy as np
import Pyro4
from warwick.observatory.common import daemons, log, TryLock
from warwick.observatory.common.helpers import pyro_client_matches
from warwick.observatory.camera.fli import (Config, CommandStatus, CameraStatus,
                                            GPSTimer, GPSFixType, GPSLocalCheckStatus)

# Set automatically when generating RPM package
SOFTWARE_VERSION = "20220215 (git-7cc9bd4)"


def process_frames(process_queue, stop_signal, camera_id,
                   output_path, log_name, pipeline_daemon_name, pipeline_handover_timeout):
    """
    Helper process to save frames to disk.
    This uses a process (rather than a thread) to avoid the GIL stalling frame acquisition
    """
    pipeline_daemon = getattr(daemons, pipeline_daemon_name)
    while True:
        frame = process_queue.get()

        start_time = frame['start_time'].strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        end_time = frame['end_time'].strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        read_end_time = frame['read_end_time'].strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]

        if frame['gps_enabled']:

            if frame['gps_time_valid']:
                gps_timestamp_status = 'VALID'
            elif frame['shutter_enabled']:
                gps_timestamp_status = 'MISSING'
            else:
                gps_timestamp_status = 'INVALID'

            gps_header = [
                (None, None, None),
                ('COMMENT', ' ---             GPS INFORMATION             --- ', ''),
                ('GPS-FIX', GPSFixType.label(frame['gps_fix_type']), 'GPS receiver fix status'),
                ('GPS-SATS', frame['gps_satellites'], 'GPS receiver satellite count'),
                ('GPS-TMST', gps_timestamp_status, 'GPS timestamp status'),
                ('TIME-CHK', round(frame['gps_last_check_delta'], 1), '[s] approximate offset of PC clock from GPS'),
            ]

            if frame['gps_start_time'] is not None:
                gps_start_time = frame['gps_start_time'].strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
                gps_header.append(('GPS-BEG', gps_start_time, '[UTC] GPS timestamp when exposure started'))
            else:
                gps_header.append(('COMMENT', ' GPS-BEG not available', ''))

            if frame['gps_end_time'] is not None:
                gps_end_time = frame['gps_end_time'].strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
                gps_header.append(('GPS-END', gps_end_time, '[UTC] GPS timestamp when exposure ended'))
            else:
                gps_header.append(('COMMENT', ' GPS-END not available', ''))
        else:
            gps_header = []

        if frame['gps_enabled'] and frame['gps_time_valid'] and gps_start_time and gps_end_time:
            date_header = [
                ('DATE-OBS', gps_start_time, '[utc] exposure start time from TIME-SRC'),
                ('DATE-END', gps_end_time, '[utc] exposure end time from TIME-SRC'),
                ('TIME-SRC', 'GPS', 'DATE-OBS is a hardware-triggered GPS timestamp'),
            ]
        else:
            date_header = [
                ('DATE-OBS', start_time, '[utc] exposure start time from TIME-SRC'),
                ('DATE-END', end_time, '[utc] exposure end time from TIME-SRC'),
                ('TIME-SRC', 'NTP', 'DATE-OBS is estimated from NTP-synced PC clock'),
            ]

        shutter_mode = 'AUTO' if frame['shutter_enabled'] else 'CLOSED'
        header = [
            (None, None, None),
            ('COMMENT', ' ---                DATE/TIME                --- ', ''),
        ] + date_header + [
            ('EXPTIME', round(frame['exposure'], 3), '[s] exposure length'),
            ('PC-BEG', start_time, '[UTC] local PC time of software trigger'),
            ('PC-RDBEG', end_time, '[UTC] local PC time when readout started'),
            ('PC-RDEND', read_end_time, '[UTC] local PC time when readout completed'),
            (None, None, None),
            ('COMMENT', ' ---           CAMERA INFORMATION            --- ', ''),
            ('CAMSWVER', SOFTWARE_VERSION, 'camera server software version'),
            ('CAMERA', '{} ({})'.format(frame['camera_model'], frame['camera_serial']),
             'camera model and serial number'),
            ('CAMID', camera_id, 'camera identifier'),
            ('CAM-TEMP', round(frame['temperature'], 2), '[deg c] CCD temperature at end of exposure'),
            ('SET-TEMP', round(frame['target_temperature'], 2), '[deg c] CCD temperature set point'),
            ('TEMP-LCK', frame['temperature_locked'], 'CCD temperature is locked to set point'),
            ('CAM-XBIN', 1, '[px] x binning'),
            ('CAM-YBIN', 1, '[px] y binning'),
            ('CAM-WIND', '[{}:{},{}:{}]'.format(
                frame['win_x'], frame['win_x'] + frame['win_width'] - 1,
                frame['win_y'], frame['win_y'] + frame['win_height'] - 1),
             '[x1:x2,y1:y2] ccd window (detector coords)'),
            ('SHUTTER', shutter_mode, 'shutter mode'),
            ('IMAG-RGN', '[{}:{},{}:{}]'.format(
                frame['image_x1'], frame['image_x2'],
                frame['image_y1'], frame['image_y2']),
             '[x1:x2,y1:y2] image region (image coords)'),
            ('EXPCNT', frame['exposure_count'], 'running exposure count since EXPCREF'),
            ('EXPCREF', frame['exposure_count_reference'], 'date the exposure counter was reset'),
            ('SHTRCNT', frame['shutter_count'], 'running shutter count since SHTRCREF'),
            ('SHTRCREF', frame['shutter_count_reference'],
             'date the shutter counter was reset')
        ] + gps_header

        hdu = fits.PrimaryHDU(frame['data'])

        # Using Card and append() to force comment cards to be placed inline
        for h in header:
            hdu.header.append(fits.Card(h[0], h[1], h[2]), end=True)

        # Save errors shouldn't interfere with preview updates, so we use a separate try/catch
        try:
            filename = '{}-{:08d}.fits'.format(camera_id, frame['exposure_count'])
            path = os.path.join(output_path, filename)

            # Simulate an atomic write by writing to a temporary file then renaming
            hdu.writeto(path + '.tmp', overwrite=True)
            shutil.move(path + '.tmp', path)
            print('Saving temporary frame: ' + filename)

        except Exception as e:
            stop_signal.value = True
            log.error(log_name, 'Failed to save temporary frame (' + str(e) + ')')

        # Hand frame over to the pipeline
        # This may block if the pipeline is busy
        try:
            with pipeline_daemon.connect(pipeline_handover_timeout) as pipeline:
                pipeline.notify_frame(camera_id, filename)
        except Exception as e:
            stop_signal.value = True
            log.error(log_name, 'Failed to hand frame to pipeline (' + str(e) + ')')


def open_device(driver, serial):
    """Returns c_long(-1) if device is not found"""
    # Enumerate cameras to find target
    devices = POINTER(c_char_p)()
    device_serial = create_string_buffer(64)
    driver.FLIList(c_long(258), byref(devices))
    if devices:
        try:
            i = 0
            while devices[i]:
                name, model = devices[i].split(b";")
                device = c_long()
                driver.FLIOpen(byref(device), name, c_long(258))
                driver.FLIGetSerialString(device, device_serial, c_size_t(64))
                if device_serial.value.decode('ascii') == serial:
                    return device, model.decode('ascii')

                driver.FLIClose(device)
                i += 1
        finally:
            driver.FLIFreeList(devices)
    return c_long(-1), None


class CameraDaemon:
    """Daemon interface for andor camera"""
    def __init__(self, config):
        self._config = config
        self._status = CameraStatus.Disabled

        if config.gps_port:
            self._timer = GPSTimer(config.gps_port, config.gps_baud, config.log_name)
        else:
            self._timer = None

        self._handle = c_long(-1)
        self._driver = None
        self._driver_lock = threading.Lock()

        self._status_condition = threading.Condition()
        self._command_lock = threading.Lock()

        self._camera_model = 'unknown'

        self._temperature = 0
        self._temperature_locked = False
        self._target_temperature = config.temperature_setpoint

        # Temperature limits: loaded during init
        self._min_temperature = 0
        self._max_temperature = 0

        # Exposured pixel area (detector coords)
        # Loaded during initialization
        self._visible_x1 = self._visible_x2 = 0
        self._visible_y1 = self._visible_y2 = 0

        # Current window region (detector coords)
        # These are *inclusive* ranges, set during initialization or by user
        self._window_x1 = self._window_x2 = 0
        self._window_y1 = self._window_y2 = 0

        # Shutter enabled (opens during exposures), or remains closed
        self._shutter_enabled = False

        self._exposure_time = 1
        self._exposure_delay = 0

        # Limit and number of frames acquired during the next sequence
        # Set to 0 to run continuously
        self._sequence_frame_limit = 0

        # Number of frames acquired this sequence
        self._sequence_frame_count = 0

        # If non-None, time that the last pre-exposure delay was started
        self._sequence_exposure_delay_start_time = None

        # Time that the latest frame in the exposure was started
        self._sequence_exposure_start_time = datetime.datetime.utcnow()

        # Information for building the output filename
        self._output_directory = pathlib.Path(config.output_path)
        self._output_frame_prefix = config.output_prefix

        # Persistent frame counters
        self._counter_filename = config.expcount_path
        try:
            with open(self._counter_filename, 'r') as infile:
                data = json.load(infile)
                self._exposure_count = data['exposure_count']
                self._exposure_count_reference = data['exposure_reference']
                self._shutter_count = data['shutter_count']
                self._shutter_count_reference = data['shutter_reference']
        except Exception:
            now = datetime.datetime.utcnow().strftime('%Y-%m-%d')
            self._exposure_count = 0
            self._exposure_count_reference = now
            self._shutter_count = 0
            self._shutter_count_reference = now

        # Thread that runs the exposure sequence
        # Initialized by start() method
        self._acquisition_thread = None

        # Signal that the exposure sequence should be terminated
        # at end of the current frame
        self._stop_acquisition = False

        self._log_acquisition_status = True

        # Condition to support cancellation of the pre-exposure delay
        self._exposure_delay_condition = threading.Condition()

        # Thread for polling camera status
        status_thread = threading.Thread(target=self.__poll_camera_status)
        status_thread.daemon = True
        status_thread.start()

        # Subprocess for processing acquired frames
        self._processing_queue = Queue()
        self._processing_stop_signal = Value(c_bool, False)

        processing_process = Process(target=process_frames, args=(
            self._processing_queue, self._processing_stop_signal, config.camera_id, config.output_path,
            config.log_name, config.pipeline_daemon_name, config.pipeline_handover_timeout))
        processing_process.daemon = True
        processing_process.start()

    def __poll_camera_status(self):
        """Background thread that polls the camera status"""
        while True:
            # Query temperature
            with self._driver_lock:
                if self._driver is not None:
                    # Query temperature status
                    temp = c_double()
                    self._driver.FLIGetTemperature(self._handle, byref(temp))
                    self._temperature = temp.value
                    temp_delta = abs(self._temperature - self._target_temperature)
                    self._temperature_locked = temp_delta < 0.5
                else:
                    self._status = CameraStatus.Disabled

            time.sleep(self._config.temperature_update_delay)

    def __set_target_temperature(self, target_temperature):
        """Set the camera temperature
           Returns True on success
        """

        with self._driver_lock:
            if self._driver is None:
                return False

            status = self._driver.FLISetTemperature(self._handle, c_double(target_temperature))
            if status != 0:
                print('failed to set temperature to {} with status {}'.format(target_temperature,
                                                                              status))
                return False

            self._target_temperature = target_temperature

            return status == 0

    def __set_shutter(self, enabled):
        """Set the shutter to open automatically or stay closed
           Returns True on success
        """
        with self._driver_lock:
            value = c_long(0 if enabled else 1)
            status = self._driver.FLISetFrameType(self._handle, value)
            if status == 0:
                self._shutter_enabled = enabled
            else:
                mode = 'auto' if enabled else 'closed'
                print('failed to set shutter {} with status {}'.format(mode, status))
            return status == 0

    def __set_exposure_time(self, exposure_seconds):
        """Sets the given exposure time in seconds
           Returns True on success
        """
        with self._driver_lock:
            exposure_ms = int(exposure_seconds * 1000)
            status = self._driver.FLISetExposureTime(self._handle, c_long(exposure_ms))
            if status == 0:
                # Use milliseconds to ensure consistency after truncation
                self._exposure_time = exposure_ms / 1000
            else:
                print('failed to set exposure ({}s) with status {}'.format(
                    exposure_seconds, status))
        return status == 0

    def __set_readout_window(self, x1, x2, y1, y2):
        """Sets the readout coordinates in 1-indexed inclusive ranges
           (for compatibility with e.g. cfitsio image slices)
           Returns True on success
        """
        x_max = self._visible_x2 - self._visible_x1
        y_max = self._visible_y2 - self._visible_y1

        if x1 >= x2 or y1 >= y2:
            return False

        if x1 < 1 or y1 < 1 or x2 > x_max or y2 > y_max:
            return False

        with self._driver_lock:
            status = self._driver.FLISetImageArea(self._handle,
                                                  c_long(self._visible_x1 + x1 - 1),
                                                  c_long(self._visible_y1 + y1 - 1),
                                                  c_long(self._visible_x1 + x2),
                                                  c_long(self._visible_y1 + y2))
            if status != 0:
                print('failed to set default readout area with status {}'.format(status))
                return False

            self._window_x1 = x1
            self._window_x2 = x2
            self._window_y1 = y1
            self._window_y2 = y2

            return True

    def __run_exposure_sequence(self):
        """Worker thread that acquires frames and their times.
           Tagged frames are pushed to the acquisition queue
           for further processing on another thread"""
        try:
            self._processing_stop_signal.value = False
            readout_width = self._window_x2 - self._window_x1 + 1
            readout_height = self._window_y2 - self._window_y1 + 1
            pixel_count = readout_width * readout_height
            while not self._stop_acquisition and not self._processing_stop_signal.value:
                if self._timer:
                    self._timer.clear_last_trigger()

                framedata = bytearray(pixel_count * 2)

                # Delay before starting exposures
                if self._exposure_delay > 0:
                    self._sequence_exposure_delay_start_time = datetime.datetime.utcnow()
                    with self._exposure_delay_condition:
                        self._exposure_delay_condition.wait(self._exposure_delay)

                    self._sequence_exposure_delay_start_time = None
                    if self._stop_acquisition or self._processing_stop_signal.value:
                        break

                with self._driver_lock:
                    start_time = datetime.datetime.utcnow()
                    status = self._driver.FLIExposeFrame(self._handle)
                if status != 0:
                    log.error(self._config.log_name, 'Failed to start exposure sequence (' + str(status) + ')')
                    break

                self._sequence_exposure_start_time = start_time

                # Wait a short time for the camera to definitely start exposing
                # This works around a race condition where FLIGetExposureStatus returns 0
                time.sleep(0.05)

                while True:
                    timeleft = c_long()
                    with self._driver_lock:
                        if self._stop_acquisition or self._processing_stop_signal.value:
                            self._driver.FLICancelExposure(self._handle)
                            break

                        status = self._driver.FLIGetExposureStatus(self._handle, byref(timeleft))

                    if status != 0 or timeleft.value == 0:
                        break

                    with self._exposure_delay_condition:
                        self._exposure_delay_condition.wait(timeleft.value / 1000.)

                if self._stop_acquisition or self._processing_stop_signal.value:
                    break

                if status != 0:
                    log.error(self._config.log_name, 'Failed to wait for acquisition (' + str(status) + ')')
                    break

                end_time = datetime.datetime.utcnow()
                cdata = (c_uint16 * pixel_count).from_buffer(framedata)
                for row in range(readout_height):
                    offset = row * readout_width * sizeof(c_uint16)
                    status = self._driver.FLIGrabRow(self._handle, byref(cdata, offset),
                                                     readout_width)
                    if status != 0:
                        break

                read_end_time = datetime.datetime.utcnow()

                if self._stop_acquisition or self._processing_stop_signal.value:
                    break

                if status != 0:
                    if not self._stop_acquisition and not self._processing_stop_signal.value:
                        log.error(self._config.log_name, 'Failed to query frame data (' + str(status) + ')')
                    break

                gps_fix_type = GPSFixType.NoFix
                gps_satellites = 0
                gps_start_time = None
                gps_end_time = None
                gps_last_check_delta = 0
                gps_time_valid = False

                if self._timer:
                    gps_start_time, gps_end_time = self._timer.last_trigger()
                    status = self._timer.report_status()
                    if status['last_check_status'] != GPSLocalCheckStatus.Unknown:
                        gps_last_check_delta = round(status['last_check_delta'], 1)
                    gps_fix_type = status['fix_type']
                    gps_satellites = status['satellites']

                    # Trigger signals are only generated when the shutter is enabled
                    gps_time_valid = gps_start_time is not None and gps_end_time is not None \
                        and self._shutter_enabled

                    if gps_time_valid:
                        # Sanity check the trigger times
                        #   - exposure lengths must agree to within 1ms
                        #   - exposure start times (corrected for clock drift)
                        #     must agree to within 250ms
                        trigger_length = (gps_end_time - gps_start_time).total_seconds()
                        exposure_delta = trigger_length - float(self._exposure_time)
                        start_delta = (gps_start_time - start_time).total_seconds() + status['last_check_delta']

                        if abs(exposure_delta) > 0.001 or abs(start_delta) > 0.25:
                            gps_time_valid = False
                            print('Trigger for exposure {} failed validation:'.format(self._exposure_count))
                            print('   GPS Start:', gps_start_time.strftime('%Y-%m-%dT%H:%M:%S.%f'))
                            print('   GPS End:', gps_end_time.strftime('%Y-%m-%dT%H:%M:%S.%f'))
                            print('   PC Start:', start_time.strftime('%Y-%m-%dT%H:%M:%S.%f'))
                            print('   Check Delta:', status['last_check_delta'])
                            print('   Exposure delta: {:.6f}'.format(exposure_delta))
                            print('   Start delta: {:.3f}'.format(start_delta))

                readout_width = self._window_x2 - self._window_x1 + 1
                readout_height = self._window_y2 - self._window_y1 + 1

                self._processing_queue.put({
                    'data': np.frombuffer(framedata, dtype=np.uint16).reshape((readout_height, readout_width)),
                    'start_time': start_time,
                    'end_time': end_time,
                    'read_end_time': read_end_time,
                    'gps_enabled': self._timer is not None,
                    'gps_fix_type': gps_fix_type,
                    'gps_satellites': gps_satellites,
                    'gps_last_check_delta': gps_last_check_delta,
                    'gps_time_valid': gps_time_valid,
                    'gps_start_time': gps_start_time,
                    'gps_end_time': gps_end_time,
                    'exposure': self._exposure_time,
                    'temperature': self._temperature,
                    'target_temperature': self._target_temperature,
                    'temperature_locked': self._temperature_locked,
                    'win_x': 1,
                    'win_width': readout_width,
                    'win_y': 1,
                    'win_height': readout_height,
                    'image_x1': 1,
                    'image_x2': readout_width,
                    'image_y1': 1,
                    'image_y2': readout_height,
                    'shutter_enabled': self._shutter_enabled,
                    'camera_model': self._camera_model,
                    'camera_serial': self._config.camera_serial,
                    'exposure_count': self._exposure_count,
                    'exposure_count_reference': self._exposure_count_reference,
                    'shutter_count': self._shutter_count,
                    'shutter_count_reference': self._shutter_count_reference
                })

                self._exposure_count += 1
                if self._shutter_enabled:
                    self._shutter_count += 1

                # Save updated counts to disk
                with open(self._counter_filename, 'w') as outfile:
                    json.dump({
                        'exposure_count': self._exposure_count,
                        'exposure_reference': self._exposure_count_reference,
                        'shutter_count': self._shutter_count,
                        'shutter_reference': self._shutter_count_reference
                    }, outfile)

                # Continue exposure sequence?
                self._sequence_frame_count += 1
                if 0 < self._sequence_frame_limit <= self._sequence_frame_count:
                    self._stop_acquisition = True
        finally:
            if self._log_acquisition_status:
                log.info(self._config.log_name, 'Exposure sequence complete')
            self._status = CameraStatus.Idle
            self._stop_acquisition = False

    @Pyro4.expose
    def set_target_temperature(self, temperature, quiet=False):
        """Set the target camera temperature"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if temperature is None or temperature < self._min_temperature or temperature > self._max_temperature:
                return CommandStatus.TemperatureOutsideLimits

            if not self.__set_target_temperature(temperature):
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Target temperature set to ' + str(temperature))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current camera state"""
        data = {'state': self._status}
        if self._status != CameraStatus.Disabled:
            # Estimate the current frame progress based on the time delta
            exposure_progress = 0
            delay_progress = 0
            if self._status == CameraStatus.Acquiring:
                if self._stop_acquisition:
                    data['state'] = CameraStatus.Aborting
                elif self._sequence_exposure_delay_start_time:
                    data['state'] = CameraStatus.Waiting
                    delta = datetime.datetime.utcnow() - self._sequence_exposure_delay_start_time
                    delay_progress = delta.total_seconds()
                else:
                    delta = datetime.datetime.utcnow() - self._sequence_exposure_start_time
                    exposure_progress = delta.total_seconds()
                    if exposure_progress > self._exposure_time:
                        data['state'] = CameraStatus.Reading
                        exposure_progress = 0

            data.update({
                'temperature': self._temperature,
                'temperature_locked': self._temperature_locked,
                'target_temperature': self._target_temperature,
                'shutter_enabled': self._shutter_enabled,
                'window': [
                    self._window_x1, self._window_x2,
                    self._window_y1, self._window_y2,
                ],
                'exposure_time': self._exposure_time,
                'exposure_progress': exposure_progress,
                'delay_time': self._exposure_delay,
                'delay_progress': delay_progress,
                'sequence_frame_limit': self._sequence_frame_limit,
                'sequence_frame_count': self._sequence_frame_count,
            })

        if self._timer:
            data['timer'] = self._timer.report_status()

        return data

    @Pyro4.expose
    def initialize(self):
        """Connects to the camera driver"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status != CameraStatus.Disabled:
                return CommandStatus.CameraNotUninitialized

            self._status = CameraStatus.Initializing
            print('initializing driver')

            driver = CDLL('/usr/local/lib/libfli.so')
            try:
                # Enumerate cameras to find target
                handle, model = open_device(driver, self._config.camera_serial)
                if handle.value < 0:
                    print('camera with serial {} was not found'.format(self._config.camera_serial))
                    return CommandStatus.CameraNotFound

                # Query detector size
                left = c_long()
                top = c_long()
                right = c_long()
                bottom = c_long()
                status = driver.FLIGetVisibleArea(handle, byref(left), byref(top),
                                                  byref(right), byref(bottom))
                if status != 0:
                    return CommandStatus.Failed

                # Set default shutter
                shutter = c_long(0 if self._shutter_enabled else 1)
                status = driver.FLISetFrameType(handle, shutter)
                if status != 0:
                    print('failed to set shutter with status {}'.format(status))
                    return CommandStatus.Failed

                # Set default exposure time
                exposure_ms = int(self._exposure_time * 1000)
                status = driver.FLISetExposureTime(handle, c_long(exposure_ms))
                if status != 0:
                    print('failed to set default exposure time with status {}'.format(status))
                    return CommandStatus.Failed

                # Set default temperature
                status = driver.FLISetTemperature(handle, c_double(self._target_temperature))
                if status != 0:
                    print('failed to set default target temperature with status {}'.format(status))
                    return CommandStatus.Failed

                # Set default binning and readout
                status = driver.FLISetHBin(handle, c_long(1))
                if status != 0:
                    print('failed to set horizontal binning with status {}'.format(status))
                    return CommandStatus.Failed

                status = driver.FLISetVBin(handle, c_long(1))
                if status != 0:
                    print('failed to set vertical binning with status {}'.format(status))
                    return CommandStatus.Failed

                # Imaging area
                visible_x1 = c_long()
                visible_y1 = c_long()
                visible_x2 = c_long()
                visible_y2 = c_long()
                status = driver.FLIGetVisibleArea(handle, byref(visible_x1), byref(visible_y1),
                                                  byref(visible_x2), byref(visible_y2))
                if status != 0:
                    print('failed to query visible area with status {}'.format(status))
                    return CommandStatus.Failed

                # Set default readout to the visible area only
                status = driver.FLISetImageArea(handle, visible_x1, visible_y1,
                                                visible_x2, visible_y2)
                if status != 0:
                    print('failed to set default readout area with status {}'.format(status))
                    return CommandStatus.Failed

                with self._driver_lock:
                    self._driver = driver
                    self._handle = handle
                    self._camera_model = model

                    # Specified in the camera documentation
                    self._min_temperature = -55
                    self._max_temperature = 45

                    self._visible_x1 = visible_x1.value
                    self._visible_y1 = visible_y1.value
                    self._visible_x2 = visible_x2.value
                    self._visible_y2 = visible_y2.value
                    self._window_x1 = self._window_y1 = 1
                    self._window_x2 = self._visible_x2 - self._visible_x1
                    self._window_y2 = self._visible_y2 - self._visible_y1

                    self._status = CameraStatus.Idle
                    print('camera {} ({}) initialized'.format(self._camera_model, self._config.camera_serial))

                return CommandStatus.Succeeded
            finally:
                # Clean up on failure
                if self._status != CameraStatus.Idle:
                    if driver is not None and handle.value >= 0:
                        driver.FLIClose(handle)
                    self._status = CameraStatus.Disabled
                    log.error(self._config.log_name, 'Failed to initialize camera')
                else:
                    log.info(self._config.log_name, 'Initialized camera')

    @Pyro4.expose
    def configure(self, params, quiet=False):
        """Set camera configuration to the requested state
           params should be a dictionary with the following keys:
              temperature: Temperature set point
              shutter: Enable the shutter (True/False)
              delay: Pre-exposure delay in seconds
              exposure: Exposure time in seconds
              window: Tuple of (x1, x2, y1, y2)
           Any properties not specified in params will be reset to its default

           The params dictionary should be validated using the
           schema returned by the configure_validation_schema helper

            Set quiet=True to disable log messages
        """
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            # Reset cooling
            temperature = params.get('temperature', self._config.temperature_setpoint)
            if not self.__set_target_temperature(temperature):
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Target temperature set to ' + str(temperature))

            # Reset shutter
            shutter = params.get('shutter', False)
            if not self.__set_shutter(shutter):
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Shutter set to ' + ('auto' if shutter else 'closed'))

            # Reset window
            window = params.get('window', [
                1, self._visible_x2 - self._visible_x1,
                1, self._visible_y2 - self._visible_y1
            ])

            if len(window) != 4 or not self.__set_readout_window(window[0], window[1],
                                                                 window[2], window[3]):
                return CommandStatus.Failed

            if not quiet:
                region = '[{}:{},{}:{}]'.format(window[0], window[1], window[2], window[3])
                log.info(self._config.log_name, 'Window set to ' + region)

            # Reset exposure delay
            self._exposure_delay = params.get('delay', 0)

            if not quiet:
                log.info(self._config.log_name, 'Exposure delay set to {:.3f}s'.format(
                    self._exposure_delay))

            # Reset exposure time
            exposure = params.get('exposure', 1)
            if not self.__set_exposure_time(exposure):
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Exposure time set to {:.3f}s'.format(exposure))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_shutter(self, enabled, quiet=False):
        """Enable or disable the shutter"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if not self.__set_shutter(enabled):
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Shutter set to ' + ('auto' if enabled else 'closed'))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure(self, seconds, quiet=False):
        """Set the exposure time in seconds"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if not self.__set_exposure_time(seconds):
                return CommandStatus.Failed

            if not quiet:
                log.info(self._config.log_name, 'Exposure time set to {:.3f}s'.format(seconds))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure_delay(self, seconds, quiet=False):
        """Set the pre-exposure delay in seconds"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            self._exposure_delay = seconds

            if not quiet:
                log.info(self._config.log_name, 'Exposure delay set to {:.3f}s'.format(seconds))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_window(self, window, quiet=False):
        """Sets the CCD readout window in unbinned (hardware) pixels"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if window is None:
                window = [
                    1, self._visible_x2 - self._visible_x1,
                    1, self._visible_y2 - self._visible_y1
                ]

            if len(window) != 4:
                return CommandStatus.Failed

            if not self.__set_readout_window(window[0], window[1], window[2], window[3]):
                return CommandStatus.WindowOutsideCCD

            if not quiet:
                region = '[{}:{},{}:{}]'.format(window[0], window[1], window[2], window[3])
                log.info(self._config.log_name, 'Window set to ' + region)
            return CommandStatus.Succeeded

    @Pyro4.expose
    def shutdown(self):
        """Disconnects from the camera driver"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            # Complete the current exposure
            if self._acquisition_thread is not None:
                with self._driver_lock:
                    self._driver.FLICancelExposure(self._handle)

                print('shutdown: waiting for acquisition to complete')
                self._stop_acquisition = True
                self._acquisition_thread.join()

            with self._driver_lock:
                print('shutdown: disconnecting driver')
                self._driver.FLIClose(self._handle)
                self._driver = None

            log.info(self._config.log_name, 'Shutdown camera')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def start_sequence(self, count, quiet=False):
        """Starts an exposure sequence with a set number of frames, or 0 to run until stopped"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            print('starting exposure sequence')
            count_msg = 'until stopped'
            if count == 1:
                count_msg = '1 frame'
            elif count > 1:
                count_msg = str(count) + ' frames'

            if not quiet:
                log.info(self._config.log_name, 'Starting exposure sequence (' + count_msg + ')')

            self._sequence_frame_limit = count
            self._sequence_frame_count = 0
            self._stop_acquisition = False
            self._log_acquisition_status = not quiet
            self._acquisition_thread = threading.Thread(target=self.__run_exposure_sequence)
            self._acquisition_thread.daemon = False
            self._acquisition_thread.start()
            self._status = CameraStatus.Acquiring

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop_sequence(self):
        """Stops any active exposure sequence"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        if self._status == CameraStatus.Disabled:
            return CommandStatus.CameraNotInitialized

        # Note that the Waiting, Reading, Aborting, statuses are artificial
        # self._status stays as CameraStatus.Acquiring during both of these
        if self._status != CameraStatus.Acquiring or self._stop_acquisition:
            return CommandStatus.CameraNotAcquiring

        log.info(self._config.log_name, 'Aborting exposure sequence')

        self._sequence_frame_count = 0
        self._stop_acquisition = True

        with self._exposure_delay_condition:
            self._exposure_delay_condition.notify_all()

        return CommandStatus.Succeeded


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Camera control daemon')
    parser.add_argument('config', help='Path to configuration json file')
    args = parser.parse_args()
    c = Config(args.config)
    c.daemon.launch(CameraDaemon(c))
